// src/lib/jarvis-memory.ts
// Full replacement file for Jarvis memory helpers.
// - Uses Supabase to save / query memory items
// - Provides extract/save/fetch/summarize utilities
// - Provides buildPromptWithMemory() to create system prompt content

import crypto from "crypto";
import { createClient } from "@/lib/supabase/server";
import { getNowInfo, NowInfo } from "@/lib/time";

const supabase = createClient();

// --------------------------- Types ---------------------------
export type MemoryItem = {
  user_id: string;
  type?: string; // e.g., "smalltalk", "preference", "trade", "event", "summary"
  text: string;
  tags?: string[]; // e.g., ["how_are_you"]
  importance?: number; // 1-10
  source?: string;
  timezone?: string;
  created_at?: string;
  hash?: string;
};

// --------------------------- Utilities ---------------------------
function makeHash(text: string) {
  return crypto.createHash("sha256").update(text).digest("hex").slice(0, 12);
}

function normalizeTags(tags?: string[] | string) {
  if (!tags) return [];
  if (Array.isArray(tags)) return tags.map((t) => String(t).toLowerCase());
  return [String(tags).toLowerCase()];
}

// --------------------------- Core DB functions ---------------------------

/**
 * Save a memory item (upserts by user_id + hash to avoid exact duplicates)
 */
export async function saveMemoryItem(item: MemoryItem) {
  const now = getNowInfo(item.timezone || "Asia/Kolkata");
  const hash = item.hash || makeHash(item.text);
  const record = {
    user_id: item.user_id?.toString(),
    type: item.type || "misc",
    text: item.text,
    tags: normalizeTags(item.tags),
    importance: item.importance ?? 3,
    source: item.source || "app",
    hash,
    created_at: item.created_at || now.iso,
    timezone: item.timezone || now.timezone,
  };

  // Supabase client typings vary by version; cast to any to avoid overload errors while preserving runtime behavior
  const { data, error } = await (supabase as any)
    .from("jarvis_memory")
    .upsert([record], { onConflict: "user_id,hash" });

  if (error) {
    console.error("saveMemoryItem error", error);
    throw error;
  }
  return data;
}

/**
 * Fetch relevant memories for a user with recency + importance weighting.
 * - intent: optional tag/keyword to filter (e.g., 'trading', 'how_are_you')
 * - horizonHours: timeframe to consider (default 7 days)
 * - maxItems: maximum records returned
 */
export async function fetchRelevantMemories(
  userId: string,
  intent: string | null = null,
  horizonHours = 24 * 7,
  maxItems = 12
) {
  const now = new Date();
  const cutoff = new Date(now.getTime() - horizonHours * 3600 * 1000).toISOString();

  let query: any = (supabase as any)
    .from("jarvis_memory")
    .select("*")
    .eq("user_id", userId.toString())
    .gte("created_at", cutoff)
    .order("importance", { ascending: false })
    .order("created_at", { ascending: false });

  if (intent) {
    // some Supabase clients allow "ilike" on tags::text; cast to any for compatibility
    query = query.ilike("tags::text", `%${intent.toLowerCase()}%`);
  }

  const { data, error } = await (query as any).limit(maxItems);

  if (error) {
    console.error("fetchRelevantMemories error", error);
    return [];
  }
  return data || [];
}

/**
 * Decide whether Jarvis should ask a question again.
 * questionKey is a tag like 'how_are_you'
 * horizonHours: do not re-ask if answered within this many hours
 * returns { shouldAsk: boolean, lastAnswer?: string|null, lastAt?: string|null }
 */
export async function shouldAskQuestion(
  userId: string,
  questionKey: string,
  horizonHours = 24
) {
  const now = new Date();
  const cutoff = new Date(now.getTime() - horizonHours * 3600 * 1000).toISOString();

  // Cast to any for ilike compatibility
  const { data, error } = await (supabase as any)
    .from("jarvis_memory")
    .select("text,created_at")
    .eq("user_id", userId.toString())
    .ilike("tags::text", `%${questionKey}%`)
    .gte("created_at", cutoff)
    .order("created_at", { ascending: false })
    .limit(1);

  if (error) {
    console.error("shouldAskQuestion error", error);
    return { shouldAsk: true, lastAnswer: null, lastAt: null };
  }

  const last = (data && data[0]) || null;
  return { shouldAsk: !last, lastAnswer: last ? last.text : null, lastAt: last ? last.created_at : null };
}

/**
 * Summarize memory (simple reducer or LLM summarizer hook).
 * - For production: replace internal summarizer below with an LLM summarization call
 *   that condenses many memory items into a short paragraph.
 */
export async function summarizeMemory(userId: string, horizonHours = 24 * 30) {
  const items = await fetchRelevantMemories(userId, null, horizonHours, 200);
  if (!items || items.length === 0) return { summary_short: "", count: 0 };

  // Lightweight summarizer: take top 20 and join; you can replace with LLM call.
  const short = items
    .slice(0, 20)
    .map((it: any) => `${it.type}:${(it.text || "").slice(0, 160)}`)
    .join("\n");

  return { summary_short: short, count: items.length, top: items.slice(0, 10) };
}

// --------------------------- Extraction ---------------------------

/**
 * Basic heuristic-based memory extractor.
 * Given a message text, decide if it should be saved and how to tag it.
 * This is intentionally simple — swap in an LLM extractor for production.
 */
export function extractMemoryFromMessage(message: string) {
  const text = (message || "").trim();
  if (!text) return null;

  const tags: string[] = [];
  let type = "misc";
  let importance = 3;

  const lowered = text.toLowerCase();

  // smalltalk detection (explicit answer patterns)
  if (
    /(i am|i'm|i feel|i got|i had|i was|i am doing|i'm doing|i had a)/i.test(lowered) &&
    /(good|bad|fine|great|terrible|sad|happy|angry|ok|okay|not good|tilted|tired|stressed|sleepy)/i.test(lowered)
  ) {
    type = "smalltalk";
    tags.push("how_are_you");
    importance = 8;
  }

  // preferences / profile
  if (/(prefer|like|love|hate|my name|my job|i am a|i work|i'm a)/i.test(lowered) || /my (name|age|job)/i.test(lowered)) {
    type = "preference";
    tags.push("preference");
    importance = Math.max(importance, 8);
  }

  // trades or numeric content
  if (/(loss|win|profit|pnl|trade|drawdown|long|short|entered at|exited at|\bunrealized\b)/i.test(lowered)) {
    type = "trade";
    tags.push("trade");
    importance = Math.max(importance, 7);
  }

  // emotional state
  if (/(sad|depressed|stressed|happy|excited|angry|tilted|anxious)/i.test(lowered)) {
    tags.push("emotion");
    importance = Math.max(importance, 7);
  }

  const shouldSave = type !== "misc" || tags.length > 0;
  if (!shouldSave) return null;

  return {
    text,
    type,
    tags,
    importance,
  } as Partial<MemoryItem>;
}

// --------------------------- Prompt builder ---------------------------

/**
 * Build system prompt parts to inject into LLM call.
 * - nowInfo: result of getNowInfo()
 * - memorySummary: output of summarizeMemory()
 * - lastAnswersForQuestions: optionally pass lastAnswer for blocked re-ask
 */
export function buildPromptWithMemory({
  nowInfo,
  memorySummary,
  lastAnswersForQuestions,
}: {
  nowInfo: NowInfo;
  memorySummary?: { summary_short: string; count: number };
  lastAnswersForQuestions?: Record<string, { lastAnswer: string | null; lastAt?: string | null }>;
}) {
  const timeBlock = `Time context:
- now: ${nowInfo.human} (ISO: ${nowInfo.iso})
- timezone: ${nowInfo.timezone}
- phase: ${nowInfo.phase}
`;

  const memoryBlock = memorySummary && memorySummary.summary_short
    ? `Recent memory summary (condensed):\n${memorySummary.summary_short}\n--- End memory summary ---`
    : "Recent memory summary: (no recent memory)";

  let repeatHints = "";
  if (lastAnswersForQuestions) {
    repeatHints = Object.entries(lastAnswersForQuestions)
      .map(([k, v]) => {
        if (!v.lastAnswer) return "";
        return `Question-key: ${k} -> Last answer (at ${v.lastAt || "unknown"}): "${v.lastAnswer}"`;
      })
      .filter(Boolean)
      .join("\n");
    if (repeatHints) repeatHints = `Repeat control:\n${repeatHints}\nDo not re-ask any of the above questions unless the user explicitly requests an update.`;
  }

  // Final system instruction template
  const systemPrompt = `
You are Jarvis — a helpful, stable, and precise assistant specialized in assisting this user.
${timeBlock}

${memoryBlock}

${repeatHints}

Rules:
- Always consult the memory summary before asking personal or repeated questions.
- Do NOT ask the same small-talk or personal question if the user answered it within the configured horizon (server-side check handles this).
- If you must reference a prior answer, do so concisely and ask if they want to update it.
- Prioritize short, actionable replies when the user's recent messages show trading context.

End system instructions.
`;
  return systemPrompt;
}

export default {
  saveMemoryItem,
  fetchRelevantMemories,
  shouldAskQuestion,
  summarizeMemory,
  extractMemoryFromMessage,
  buildPromptWithMemory,
};
